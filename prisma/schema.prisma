// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// This block configures the Prisma client, specifying that it should generate a client that uses Prisma's JavaScript client library.
generator client {
  provider = "prisma-client-js"
}

// This block configures the database connection, specifying MongoDB as the database provider and using an environment variable for the connection string.
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// Defines a User model, representing a collection in MongoDB for user data.
model User {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId // MongoDB's unique identifier for each user, auto-generated.
  name           String?
  email          String?   @unique // Unique email address for the user.
  emailVerified  DateTime? // Optional field to store email verification date and time.
  image          String?   // Optional field to store user's profile image URL.
  hashedPassword String?   // Optional field for storing the hashed password.
  createdAt      DateTime  @default(now()) // Automatically sets to the current date and time when a User record is created.
  updatedAt      DateTime  @updatedAt // Automatically updates to the current date and time whenever a User record is updated.

  // Fields defining relations to other models:
  conversationIds String[]       @db.ObjectId // Array of ObjectIds relating to conversations the user is part of.
  conversations   Conversation[] @relation(fields: [conversationIds], references: [id]) // Sets up a relation to the Conversation model.

  seenMessageIds String[]  @db.ObjectId // Array of ObjectIds for messages the user has seen.
  seenMessages   Message[] @relation("Seen", fields: [seenMessageIds], references: [id]) // Relation to the Message model for seen messages.

  accounts Account[] // Relation to the Account model, one User can have many accounts.
  messages Message[] // Relation to the Message model, one User can send many messages.
}

// Defines an Account model for storing user account information related to different providers.
model Account {
  id                String @id @default(auto()) @map("_id") @db.ObjectId // Unique identifier for each account, auto-generated.
  userId            String @db.ObjectId // ObjectId of the User this account belongs to.
  type              String // Type of the account (e.g., OAuth, local).
  provider          String // The service providing the account (e.g., Google, Facebook).
  providerAccountId String // The account ID from the provider.

  // Optional fields for OAuth tokens and related information:
  refresh_token String? @db.String // Optional string to store the refresh token, which can be used to obtain a new access token once the current one expires.
  access_token  String? @db.String // Optional string to store the access token, which is used to authenticate API requests on behalf of the user.
  expires_at    Int?    // Optional integer to store the expiration time of the access token, typically represented as a Unix timestamp.
  token_type    String? // Optional string to specify the type of token issued (e.g., Bearer).
  scope         String? // Optional string to specify the scope of the access token as defined by the authorization server.
  id_token      String? @db.String // Optional string to store the ID token, which contains identity information about the user.
  session_state String? // Optional string to store the session state, which might be used by the authorization server to manage user sessions.

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // Relation to the User model, with cascade delete.

  @@unique([provider, providerAccountId]) // Ensures the combination of provider and providerAccountId is unique.
}

// Defines a Conversation model for storing conversation data.
model Conversation {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId // Unique identifier for each conversation, auto-generated.
  createdAt     DateTime @default(now()) // Sets the creation date and time of the conversation.
  lastMessageAt DateTime @default(now()) // Sets the date and time of the last message in the conversation.
  name          String?  // Optional name of the conversation, useful for group chats.
  isGroup       Boolean? // Optional boolean indicating if the conversation is a group chat.

  messagesIds String[]  @db.ObjectId // Array of ObjectIds for messages in the conversation.
  messages    Message[] // Relation to the Message model.

  userIds String[] @db.ObjectId // Array of ObjectIds for users in the conversation.
  users   User[]   @relation(fields: [userIds], references: [id]) // Relation to the User model.
}

// Defines a Message model for storing message data within conversations.
model Message {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId // Unique identifier for each message, auto-generated.
  body      String?  // Optional message text.
  image     String?  // Optional URL for an image attached to the message.
  createdAt DateTime @default(now()) // Sets the creation date and time of the message.

  // Fields for managing message visibility and ownership:
  seenIds String[] @db.ObjectId // Array of ObjectIds for users who have seen the message.
  seen    User[]   @relation("Seen", fields: [seenIds], references: [id]) // Relation to User model for users who have seen the message.

  conversationId String       @db.ObjectId // ObjectId of the conversation this message belongs to.
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade) // Relation to Conversation model, with cascade delete.

  senderId String @db.ObjectId // ObjectId of the user who sent the message.
  sender   User   @relation(fields: [senderId], references: [id], onDelete: Cascade) // Relation to the User model for the message sender, with cascade delete.
}
